# Безопасность Auth Service

**Важно:** Этот документ описывает аспекты безопасности. Актуальным и исчерпывающим источником спецификаций безопасности, включая алгоритмы и конфигурации, является `auth_microservice_specification_final.md`.

## Содержание

- [Обзор безопасности](#обзор-безопасности)
- [Аутентификация](#аутентификация)
  - [Пароли](#пароли)
  - [JWT-токены](#jwt-токены)
  - [Двухфакторная аутентификация](#двухфакторная-аутентификация)
  - [Telegram Login](#telegram-login)
- [Авторизация](#авторизация)
  - [Ролевая модель (RBAC)](#ролевая-модель-rbac)
  - [Проверка разрешений](#проверка-разрешений)
- [Защита данных](#защита-данных)
  - [Шифрование данных](#шифрование-данных)
  - [Управление секретами](#управление-секретами)
  - [Защита персональных данных](#защита-персональных-данных)
- [Защита от атак](#защита-от-атак)
  - [CSRF](#csrf)
  - [XSS](#xss)
  - [SQL-инъекции](#sql-инъекции)
  - [Брутфорс-атаки](#брутфорс-атаки)
  - [Rate Limiting](#rate-limiting)
- [Аудит безопасности](#аудит-безопасности)
  - [Логирование событий безопасности](#логирование-событий-безопасности)
  - [Мониторинг подозрительной активности](#мониторинг-подозрительной-активности)
- [Безопасность инфраструктуры](#безопасность-инфраструктуры)
  - [Сетевая безопасность](#сетевая-безопасность)
  - [Безопасность контейнеров](#безопасность-контейнеров)
  - [Безопасность Kubernetes](#безопасность-kubernetes)
- [Соответствие стандартам](#соответствие-стандартам)
  - [GDPR](#gdpr)
  - [PCI DSS](#pci-dss)
  - [OWASP Top 10](#owasp-top-10)
- [Процедуры безопасности](#процедуры-безопасности)
  - [Реагирование на инциденты](#реагирование-на-инциденты)
  - [Управление уязвимостями](#управление-уязвимостями)
  - [Обновление компонентов](#обновление-компонентов)

## Обзор безопасности

Auth Service является критически важным компонентом платформы, отвечающим за аутентификацию и авторизацию пользователей. Безопасность сервиса построена на принципе глубокой защиты (Defense in Depth), который предполагает использование нескольких уровней защиты для обеспечения безопасности системы.

Основные принципы безопасности Auth Service:
- Минимальные привилегии (Principle of Least Privilege)
- Многоуровневая защита (Defense in Depth)
- Безопасность по умолчанию (Secure by Default)
- Прозрачность и аудит (Transparency and Audit)
- Постоянное совершенствование (Continuous Improvement)

## Аутентификация

### Пароли

Auth Service использует следующие механизмы для обеспечения безопасности паролей:

1. **Хеширование паролей**
   - Алгоритм: Argon2id
   - Стоимость (cost): Рекомендуется использовать значения по умолчанию или настроенные в соответствии с лучшими практиками для Argon2id.
   - Соль: генерируется автоматически для каждого пароля

   ```go
   // Пример хеширования пароля (иллюстративный, реальная реализация может отличаться для Argon2id)
   // import "golang.org/x/crypto/argon2" // Пример импорта для Argon2id

   // Функция для хеширования пароля с использованием Argon2id (параметры для примера)
   // func HashPassword(password string, salt []byte) (string, error) {
   //     // Параметры Argon2id (время, память, потоки, длина ключа)
   //     // Важно: Эти параметры должны быть тщательно подобраны
   //     hashedPassword := argon2.IDKey([]byte(password), salt, 1, 64*1024, 4, 32)
   //     return string(hashedPassword), nil // Реальное хранение должно включать соль и параметры
   // }
   ```

2. **Политика паролей**
   - Минимальная длина: 8 символов
   - Требования к сложности: минимум 1 заглавная буква, 1 строчная буква, 1 цифра, 1 специальный символ
   - Проверка на распространенные пароли
   - Проверка на повторное использование паролей

   ```go
   // Пример валидации пароля
   func validatePassword(password string) error {
       if len(password) < 8 {
           return errors.New("password must be at least 8 characters long")
       }
       // Другие проверки...
       return nil
   }
   ```

3. **Управление сроком действия паролей**
   - Максимальный срок действия: 90 дней
   - История паролей: запрет на повторное использование последних 5 паролей
   - Принудительная смена пароля при первом входе (для паролей, созданных администратором)

### JWT-токены

Auth Service использует JWT (JSON Web Tokens) для аутентификации пользователей:

1. **Структура токенов**
   - Access Token: короткоживущий токен для доступа к API
   - Refresh Token: долгоживущий токен для обновления Access Token

2. **Параметры токенов**
   - Алгоритм подписи: RS256 (RSA с SHA-256)
   - Время жизни Access Token: 15 минут (настраивается)
   - Время жизни Refresh Token: 30 дней (настраивается)
   - Ротация ключей: каждые 30 дней

   ```go
   // Пример создания JWT-токена (иллюстративный, с использованием RS256)
   // import "github.com/golang-jwt/jwt/v5" // Актуальный пакет

   // Для RS256 требуется загрузка приватного ключа RSA
   // var rsaPrivateKey *rsa.PrivateKey

   // func GenerateJWT(userID string /*, rsaPrivateKey *rsa.PrivateKey */) (string, error) {
   //     claims := jwt.MapClaims{
   //         "user_id": userID,
   //         "exp":     time.Now().Add(time.Hour * 1).Unix(), // Срок действия - 1 час
   //     }
   //     // Примечание: jwt.SigningMethodRS256 требует *rsa.PrivateKey для подписи
   //     // и *rsa.PublicKey для проверки.
   //     token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
   //     // tokenString, err := token.SignedString(rsaPrivateKey)
   //     // return tokenString, err
   //     return "иллюстративный_токен_RS256", nil // Заглушка для примера в Markdown
   // }
   ```

3. **Безопасность токенов**
   - Хранение Refresh Token в Redis с возможностью отзыва
   - Проверка IP-адреса при использовании Refresh Token
   - Отзыв всех токенов при смене пароля
   - Blacklisting отозванных токенов

   ```go
   // Пример проверки токена
   func validateToken(tokenString string) (*jwt.Token, error) {
       token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
           if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
               return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
           }
           return []byte(jwtSecret), nil
       })
       if err != nil {
           return nil, err
       }
       if !token.Valid {
           return nil, errors.New("invalid token")
       }
       return token, nil
   }
   ```

### Двухфакторная аутентификация

Auth Service поддерживает двухфакторную аутентификацию (2FA) с использованием TOTP (Time-based One-Time Password):

1. **Реализация TOTP**
   - Алгоритм: TOTP (RFC 6238)
   - Хеш-функция: SHA-1
   - Длина кода: 6 цифр
   - Интервал: 30 секунд
   - Окно проверки: ±1 интервал

   ```go
   // Пример генерации TOTP-секрета
   func generateTOTPSecret() string {
       return base32.StdEncoding.EncodeToString(securecrypto.RandomBytes(20))
   }
   
   // Пример проверки TOTP-кода
   func validateTOTPCode(secret string, code string) bool {
       return totp.Validate(code, secret)
   }
   ```

2. **Резервные коды**
   - Количество: 10 кодов
   - Формат: 8 символов (буквы и цифры)
   - Одноразовое использование
   - Хранение: в виде хешей bcrypt

3. **Процесс включения 2FA**
   - Генерация секрета
   - Отображение QR-кода для сканирования
   - Проверка введенного кода
   - Генерация и сохранение резервных кодов

4. **Процесс аутентификации с 2FA**
   - Стандартная аутентификация по логину/паролю
   - Запрос TOTP-кода
   - Проверка TOTP-кода или резервного кода
   - Выдача токенов при успешной проверке

### Telegram Login

Auth Service поддерживает аутентификацию через Telegram Login:

1. **Процесс аутентификации**
   - Получение данных от Telegram Login Widget
   - Проверка подписи данных с использованием токена бота
   - Проверка актуальности данных (auth_date)
   - Создание или обновление пользователя
   - Выдача токенов при успешной проверке

   ```go
   // Пример проверки данных Telegram Login
   func validateTelegramData(data map[string]string, botToken string) bool {
       // Создание строки для проверки
       checkString := createCheckString(data)
       
       // Создание хеша
       secretKey := sha256.Sum256([]byte(botToken))
       hash := hmac.New(sha256.New, secretKey[:])
       hash.Write([]byte(checkString))
       
       // Проверка подписи
       signature := hex.EncodeToString(hash.Sum(nil))
       return signature == data["hash"]
   }
   ```

2. **Безопасность Telegram Login**
   - Проверка времени авторизации (не более 24 часов)
   - Связывание Telegram-аккаунта с существующим аккаунтом при наличии
   - Возможность отвязать Telegram-аккаунт

## Авторизация

### Ролевая модель (RBAC)

Auth Service использует ролевую модель контроля доступа (Role-Based Access Control, RBAC):

1. **Структура RBAC**
   - Пользователи (Users)
   - Роли (Roles)
   - Разрешения (Permissions)
   - Связи пользователей и ролей (User-Role Assignments)

2. **Предопределенные роли**
   - `admin`: Администратор системы
   - `user`: Обычный пользователь
   - `developer`: Разработчик
   - `moderator`: Модератор
   - `support`: Поддержка

3. **Иерархия ролей**
   - Поддержка наследования ролей
   - Пример: `admin` наследует все разрешения `moderator`

   ```go
   // Пример структуры роли
   type Role struct {
       ID          string
       Name        string
       Description string
       Permissions []string
       ParentRoles []string
   }
   ```

4. **Управление ролями**
   - Создание и удаление ролей
   - Назначение и отзыв ролей у пользователей
   - Добавление и удаление разрешений у ролей

### Проверка разрешений

Auth Service предоставляет механизмы для проверки разрешений:

1. **Формат разрешений**
   - Формат: `resource.action`
   - Примеры: `users.read`, `roles.write`, `games.publish`

2. **Проверка разрешений**
   - На уровне API (middleware)
   - На уровне сервисов
   - Через gRPC для других микросервисов

   ```go
   // Пример проверки разрешения
   func checkPermission(userID string, permission string) bool {
       // Получение ролей пользователя
       roles := getUserRoles(userID)
       
       // Проверка разрешения для каждой роли
       for _, role := range roles {
           if hasPermission(role, permission) {
               return true
           }
       }
       
       return false
   }
   ```

3. **Кэширование разрешений**
   - Кэширование ролей пользователя в Redis
   - Кэширование результатов проверки разрешений
   - Инвалидация кэша при изменении ролей

## Защита данных

### Шифрование данных

Auth Service использует следующие механизмы шифрования данных:

1. **Шифрование в покое (Data at Rest)**
   - Шифрование базы данных PostgreSQL (на уровне файловой системы)
   - Шифрование резервных копий

2. **Шифрование в передаче (Data in Transit)**
   - TLS для всех HTTP и gRPC соединений
   - TLS для соединений с PostgreSQL и Redis
   - TLS для соединений с Kafka

3. **Шифрование чувствительных данных**
   - Шифрование TOTP-секретов
   - Шифрование резервных кодов 2FA
   - Шифрование токенов внешних сервисов

   ```go
   // Пример шифрования данных
   func encryptData(data []byte, key []byte) ([]byte, error) {
       block, err := aes.NewCipher(key)
       if err != nil {
           return nil, err
       }
       
       gcm, err := cipher.NewGCM(block)
       if err != nil {
           return nil, err
       }
       
       nonce := make([]byte, gcm.NonceSize())
       if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
           return nil, err
       }
       
       return gcm.Seal(nonce, nonce, data, nil), nil
   }
   ```

### Управление секретами

Auth Service использует следующие механизмы для управления секретами:

1. **HashiCorp Vault**
   - Хранение секретов приложения
   - Динамические учетные данные для баз данных
   - Ротация секретов

   ```go
   // Пример получения секрета из Vault
   func getSecretFromVault(path string) (string, error) {
       client, err := vault.NewClient(vault.DefaultConfig())
       if err != nil {
           return "", err
       }
       
       secret, err := client.Logical().Read(path)
       if err != nil {
           return "", err
       }
       
       return secret.Data["value"].(string), nil
   }
   ```

2. **Kubernetes Secrets**
   - Хранение секретов для развертывания
   - Монтирование секретов в контейнеры
   - Интеграция с Vault через Vault Injector

3. **Управление ключами**
   - Ротация ключей шифрования
   - Ротация ключей подписи JWT
   - Версионирование ключей

### Защита персональных данных

Auth Service обеспечивает защиту персональных данных пользователей:

1. **Минимизация данных**
   - Сбор только необходимых данных
   - Удаление неиспользуемых данных

2. **Анонимизация и псевдонимизация**
   - Использование идентификаторов вместо персональных данных
   - Анонимизация данных для аналитики

3. **Управление согласиями**
   - Получение согласия на обработку данных
   - Хранение истории согласий
   - Возможность отзыва согласия

4. **Право на забвение**
   - Полное удаление данных пользователя по запросу
   - Каскадное удаление связанных данных

## Защита от атак

### CSRF

Auth Service реализует защиту от CSRF (Cross-Site Request Forgery):

1. **Механизмы защиты**
   - Использование JWT-токенов в заголовке Authorization
   - CSRF-токены для форм
   - Проверка заголовка Origin/Referer

   ```go
   // Пример middleware для защиты от CSRF
   func CSRFMiddleware() gin.HandlerFunc {
       return func(c *gin.Context) {
           // Проверка метода
           if c.Request.Method != "GET" && c.Request.Method != "HEAD" && c.Request.Method != "OPTIONS" {
               // Проверка заголовка Origin
               origin := c.GetHeader("Origin")
               if origin != "" && !isAllowedOrigin(origin) {
                   c.AbortWithStatus(http.StatusForbidden)
                   return
               }
               
               // Проверка CSRF-токена для форм
               if c.ContentType() == "application/x-www-form-urlencoded" {
                   token := c.GetHeader("X-CSRF-Token")
                   if token == "" || !validateCSRFToken(token, c.GetString("user_id")) {
                       c.AbortWithStatus(http.StatusForbidden)
                       return
                   }
               }
           }
           
           c.Next()
       }
   }
   ```

2. **Настройка CORS**
   - Ограничение разрешенных источников
   - Ограничение разрешенных методов
   - Ограничение разрешенных заголовков

### XSS

Auth Service реализует защиту от XSS (Cross-Site Scripting):

1. **Механизмы защиты**
   - Экранирование выходных данных
   - Валидация входных данных
   - Заголовки безопасности (Content-Security-Policy, X-XSS-Protection)

   ```go
   // Пример настройки заголовков безопасности
   func SecurityHeadersMiddleware() gin.HandlerFunc {
       return func(c *gin.Context) {
           c.Header("Content-Security-Policy", "default-src 'self'")
           c.Header("X-XSS-Protection", "1; mode=block")
           c.Header("X-Content-Type-Options", "nosniff")
           c.Header("X-Frame-Options", "DENY")
           c.Header("Referrer-Policy", "strict-origin-when-cross-origin")
           c.Next()
       }
   }
   ```

2. **Безопасная обработка JSON**
   - Использование безопасных методов маршалинга/анмаршалинга
   - Проверка типов данных

### SQL-инъекции

Auth Service реализует защиту от SQL-инъекций:

1. **Механизмы защиты**
   - Использование параметризованных запросов
   - Использование ORM (Object-Relational Mapping)
   - Валидация входных данных

   ```go
   // Пример безопасного запроса к базе данных
   func getUserByEmail(email string) (*User, error) {
       var user User
       err := db.QueryRow("SELECT id, email, password FROM users WHERE email = $1", email).Scan(&user.ID, &user.Email, &user.Password)
       if err != nil {
           return nil, err
       }
       return &user, nil
   }
   ```

2. **Ограничение привилегий**
   - Использование разных пользователей БД для разных операций
   - Минимальные привилегии для пользователя БД

### Брутфорс-атаки

Auth Service реализует защиту от брутфорс-атак:

1. **Механизмы защиты**
   - Ограничение количества попыток входа
   - Временная блокировка аккаунта после нескольких неудачных попыток
   - Капча после нескольких неудачных попыток
   - Экспоненциальная задержка между попытками

   ```go
   // Пример проверки количества неудачных попыток
   func checkLoginAttempts(userID string) error {
       attempts, err := getLoginAttempts(userID)
       if err != nil {
           return err
       }
       
       if attempts >= 5 {
           // Временная блокировка аккаунта
           lockAccount(userID, 15*time.Minute)
           return errors.New("account temporarily locked due to too many failed login attempts")
       }
       
       return nil
   }
   ```

2. **Мониторинг и оповещение**
   - Логирование всех попыток входа
   - Оповещение о подозрительной активности
   - Анализ паттернов атак

### Rate Limiting

Auth Service реализует ограничение запросов (Rate Limiting):

1. **Механизмы ограничения**
   - Ограничение по IP-адресу
   - Ограничение по пользователю
   - Ограничение по эндпоинту

   ```go
   // Пример middleware для ограничения запросов
   func RateLimitMiddleware(limit int, period time.Duration) gin.HandlerFunc {
       limiter := rate.NewLimiter(rate.Every(period), limit)
       return func(c *gin.Context) {
           // Получение ключа для ограничения (IP или user_id)
           key := c.ClientIP()
           if userID := c.GetString("user_id"); userID != "" {
               key = userID
           }
           
           // Проверка лимита
           if !limiter.Allow() {
               c.AbortWithStatus(http.StatusTooManyRequests)
               return
           }
           
           c.Next()
       }
   }
   ```

2. **Гибкие политики**
   - Разные лимиты для разных эндпоинтов
   - Разные лимиты для разных ролей
   - Динамическое изменение лимитов

## Аудит безопасности

### Логирование событий безопасности

Auth Service реализует логирование всех событий безопасности:

1. **События для логирования**
   - Попытки входа (успешные и неудачные)
   - Изменение ролей и разрешений
   - Изменение пароля
   - Включение/отключение 2FA
   - Отзыв токенов
   - Блокировка/разблокировка аккаунта

   ```go
   // Пример логирования события безопасности
   func logSecurityEvent(userID string, eventType string, details map[string]interface{}) error {
       event := SecurityEvent{
           UserID:    userID,
           EventType: eventType,
           Details:   details,
           Timestamp: time.Now(),
           IP:        getClientIP(),
           UserAgent: getUserAgent(),
       }
       
       return saveSecurityEvent(event)
   }
   ```

2. **Формат логов**
   - Структурированные логи в формате JSON
   - Включение контекста (IP, User-Agent, Session ID)
   - Корреляционный ID для связывания событий

3. **Хранение логов**
   - Долгосрочное хранение в базе данных
   - Экспорт в системы SIEM
   - Защита от изменения (append-only)

### Мониторинг подозрительной активности

Auth Service реализует мониторинг подозрительной активности:

1. **Признаки подозрительной активности**
   - Множественные неудачные попытки входа
   - Вход с нового устройства или локации
   - Необычное время активности
   - Быстрое изменение ролей и разрешений
   - Множественные запросы к API

2. **Реакция на подозрительную активность**
   - Оповещение администраторов
   - Временная блокировка аккаунта
   - Запрос дополнительной аутентификации
   - Ограничение доступа

3. **Анализ паттернов**
   - Машинное обучение для выявления аномалий
   - Анализ исторических данных
   - Профилирование пользователей

## Безопасность инфраструктуры

### Сетевая безопасность

Auth Service обеспечивает сетевую безопасность:

1. **Сегментация сети**
   - Разделение на подсети (frontend, backend, database)
   - Использование Network Policies в Kubernetes
   - Ограничение доступа между сервисами

2. **Шифрование трафика**
   - TLS для всех внешних соединений
   - mTLS для внутренних соединений (с использованием Istio)
   - Современные протоколы и шифры

3. **Защита периметра**
   - Web Application Firewall (WAF)
   - DDoS-защита
   - Intrusion Detection/Prevention System (IDS/IPS)

### Безопасность контейнеров

Auth Service обеспечивает безопасность контейнеров:

1. **Безопасность образов**
   - Минимальные базовые образы
   - Сканирование уязвимостей
   - Подпись образов

2. **Безопасность контейнеров в runtime**
   - Запуск от непривилегированного пользователя
   - Read-only файловая система
   - Ограничение возможностей (capabilities)
   - Ограничение ресурсов

3. **Безопасность реестра образов**
   - Аутентификация и авторизация
   - Сканирование уязвимостей
   - Политики для образов

### Безопасность Kubernetes

Auth Service обеспечивает безопасность в Kubernetes:

1. **Безопасность кластера**
   - RBAC для доступа к API
   - Network Policies для сегментации сети
   - Pod Security Policies для ограничения привилегий
   - Audit Logging для отслеживания действий

2. **Безопасность развертывания**
   - Использование Helm для управления развертыванием
   - Проверка манифестов на соответствие политикам
   - Использование Secrets для хранения чувствительных данных

3. **Безопасность Service Mesh**
   - Взаимная аутентификация (mTLS) с использованием Istio
   - Авторизация на уровне запросов
   - Мониторинг и трассировка

## Соответствие стандартам

### GDPR

Auth Service обеспечивает соответствие требованиям GDPR (General Data Protection Regulation):

1. **Обработка персональных данных**
   - Минимизация данных
   - Ограничение срока хранения
   - Шифрование персональных данных

2. **Права субъектов данных**
   - Право на доступ к данным
   - Право на исправление данных
   - Право на удаление данных
   - Право на ограничение обработки

3. **Документирование обработки**
   - Реестр операций обработки
   - Оценка воздействия на защиту данных
   - Политика конфиденциальности

### PCI DSS

Auth Service обеспечивает соответствие требованиям PCI DSS (Payment Card Industry Data Security Standard):

1. **Защита данных держателей карт**
   - Шифрование данных
   - Ограничение доступа
   - Маскирование данных

2. **Управление доступом**
   - Уникальные идентификаторы для каждого пользователя
   - Многофакторная аутентификация
   - Ограничение физического доступа

3. **Мониторинг и тестирование**
   - Регулярное тестирование безопасности
   - Мониторинг доступа к сетевым ресурсам
   - Регулярные проверки безопасности

### OWASP Top 10

Auth Service обеспечивает защиту от уязвимостей из списка OWASP Top 10:

1. **A1:2021 - Broken Access Control**
   - Ролевая модель контроля доступа (RBAC)
   - Проверка разрешений на всех уровнях
   - Принцип минимальных привилегий

2. **A2:2021 - Cryptographic Failures**
   - Современные алгоритмы шифрования
   - Безопасное хранение ключей
   - Защита данных в покое и при передаче

3. **A3:2021 - Injection**
   - Параметризованные запросы
   - Валидация входных данных
   - Экранирование выходных данных

4. **A7:2021 - Identification and Authentication Failures**
   - Многофакторная аутентификация
   - Защита от брутфорс-атак
   - Безопасное управление сессиями

## Процедуры безопасности

### Реагирование на инциденты

Auth Service имеет процедуры реагирования на инциденты безопасности:

1. **Выявление инцидентов**
   - Мониторинг логов и метрик
   - Оповещения о подозрительной активности
   - Регулярные проверки безопасности

2. **Реагирование на инциденты**
   - Классификация инцидентов по уровню критичности
   - Процедуры для каждого типа инцидента
   - Команда реагирования на инциденты

3. **Восстановление после инцидентов**
   - Процедуры восстановления данных
   - Анализ причин инцидента
   - Улучшение защиты на основе анализа

### Управление уязвимостями

Auth Service имеет процедуры управления уязвимостями:

1. **Выявление уязвимостей**
   - Сканирование кода на уязвимости
   - Сканирование зависимостей
   - Сканирование инфраструктуры
   - Регулярные пентесты

2. **Оценка уязвимостей**
   - Классификация по уровню критичности
   - Оценка потенциального воздействия
   - Приоритизация устранения

3. **Устранение уязвимостей**
   - Процедуры патчинга
   - Временные меры защиты
   - Верификация устранения

### Обновление компонентов

Auth Service имеет процедуры обновления компонентов:

1. **Мониторинг обновлений**
   - Отслеживание обновлений зависимостей
   - Отслеживание обновлений инфраструктуры
   - Отслеживание уведомлений о безопасности

2. **Тестирование обновлений**
   - Тестирование в изолированной среде
   - Автоматизированные тесты
   - Постепенное развертывание

3. **Развертывание обновлений**
   - Процедуры развертывания
   - Возможность отката
   - Мониторинг после развертывания
